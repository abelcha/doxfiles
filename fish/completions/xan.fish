complete -c xan -f -n '__fish_use_subcommand' #BASENOFILE
complete -c xan -s h -l help -d 'Display this message'
complete -c xan -n __fish_no_arguments -l version -d 'Print version info and exit'
complete -c xan -n '__fish_use_subcommand' -a 'headers'     -d "(h) Show header names"
complete -c xan -n '__fish_use_subcommand' -a 'view'        -d "(v) Preview a CSV file in a human-friendly way"
complete -c xan -n '__fish_use_subcommand' -a 'flatten'     -d "(f) Display a flattened version of each row of a file"
complete -c xan -n '__fish_use_subcommand' -a 'hist'        -d "Print a histogram with rows of CSV file as bars"
complete -c xan -n '__fish_use_subcommand' -a 'plot'        -d "Draw a scatter plot or line chart"
complete -c xan -n '__fish_use_subcommand' -a 'heatmap'     -d "Draw a heatmap of a CSV matrix"
complete -c xan -n '__fish_use_subcommand' -a 'progress'    -d "Display a progress bar while reading CSV data"
complete -c xan -n '__fish_use_subcommand' -a 'search'      -d "Search for (or replace) patterns in CSV data"
complete -c xan -n '__fish_use_subcommand' -a 'filter'      -d "Only keep some CSV rows based on an evaluated expression"
complete -c xan -n '__fish_use_subcommand' -a 'slice'       -d "Slice rows of CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'top'         -d "Find top rows of a CSV file according to some column"
complete -c xan -n '__fish_use_subcommand' -a 'sample'      -d "Randomly sample CSV data"
complete -c xan -n '__fish_use_subcommand' -a 'sort'        -d "Sort CSV data"
complete -c xan -n '__fish_use_subcommand' -a 'dedup'       -d "Deduplicate a CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'shuffle'     -d "Shuffle CSV data"
complete -c xan -n '__fish_use_subcommand' -a 'frequency'   -d "(freq) Show frequency tables"
complete -c xan -n '__fish_use_subcommand' -a 'groupby'     -d "Aggregate data by groups of a CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'stats'       -d "Compute basic statistics"
complete -c xan -n '__fish_use_subcommand' -a 'agg'         -d "Aggregate data from CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'bins'        -d "Dispatch numeric columns into bins"
complete -c xan -n '__fish_use_subcommand' -a 'cat'         -d "Concatenate by row or column"
complete -c xan -n '__fish_use_subcommand' -a 'join'        -d "Join CSV files"
complete -c xan -n '__fish_use_subcommand' -a 'regex-join'  -d "Fuzzy join CSV files using regex patterns"
complete -c xan -n '__fish_use_subcommand' -a 'url-join'    -d "Join CSV files on url prefixes"
complete -c xan -n '__fish_use_subcommand' -a 'merge'       -d "Merge multiple similar already sorted CSV files"
complete -c xan -n '__fish_use_subcommand' -a 'select'      -d "Select columns from a CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'drop'        -d "Drop columns from a CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'map'         -d "Create a new column by evaluating an expression on each CSV row"
complete -c xan -n '__fish_use_subcommand' -a 'transform'   -d "Transform a column by evaluating an expression on each CSV row"
complete -c xan -n '__fish_use_subcommand' -a 'enum'        -d "Enumerate CSV file by preprending an index column"
complete -c xan -n '__fish_use_subcommand' -a 'flatmap'     -d "Emit one row per value yielded by an expression evaluated for each CSV row"
complete -c xan -n '__fish_use_subcommand' -a 'fill'        -d "Fill empty cells"
complete -c xan -n '__fish_use_subcommand' -a 'blank'       -d "Blank down contiguous identical cell values"
complete -c xan -n '__fish_use_subcommand' -a 'behead'      -d "  Drop header from CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'rename'      -d "  Rename columns of a CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'input'       -d "  Read unusually formatted CSV data"
complete -c xan -n '__fish_use_subcommand' -a 'fixlengths'  -d "  Makes all rows have same length"
complete -c xan -n '__fish_use_subcommand' -a 'fmt'         -d "  Format CSV output (change field delimiter)"
complete -c xan -n '__fish_use_subcommand' -a 'explode'     -d "  Explode rows based on some column separator"
complete -c xan -n '__fish_use_subcommand' -a 'implode'     -d "  Collapse consecutive identical rows based on a diverging column"
complete -c xan -n '__fish_use_subcommand' -a 'from'        -d "  Convert a variety of formats to CSV"
complete -c xan -n '__fish_use_subcommand' -a 'to'          -d "  Convert a CSV file to a variety of data formats"
complete -c xan -n '__fish_use_subcommand' -a 'scrape'      -d "  Scrape HTML into CSV data"
complete -c xan -n '__fish_use_subcommand' -a 'reverse'     -d "  Reverse rows of CSV data"
complete -c xan -n '__fish_use_subcommand' -a 'transpose'   -d "(t) Transpose CSV file"
complete -c xan -n '__fish_use_subcommand' -a 'split'       -d "Split CSV data into chunks"
complete -c xan -n '__fish_use_subcommand' -a 'partition'   -d "Partition CSV data based on a column value"
complete -c xan -n '__fish_use_subcommand' -a 'parallel'    -d "(p) Map-reduce-like parallel computation over multiple CSV files"
complete -c xan -n '__fish_use_subcommand' -a 'range'       -d "Create a CSV file from a numerical range"
complete -c xan -n '__fish_use_subcommand' -a 'eval'        -d "Evaluate/debug a single expression"
complete -c xan -n '__fish_use_subcommand' -a 'foreach'     -d "Loop over a CSV file to perform side effects"
complete -c xan -n '__fish_use_subcommand' -a 'tokenize'    -d "Tokenize a text column"
complete -c xan -n '__fish_use_subcommand' -a 'vocab'       -d "Build a vocabulary over tokenized documents"
complete -c xan -n '__fish_use_subcommand' -a 'cluster'     -d "Cluster CSV data to find near-duplicates"
complete -c xan -n '__fish_use_subcommand' -a 'matrix'      -d "Convert CSV data to matrix data"
complete -c xan -n '__fish_use_subcommand' -a 'network'     -d "Convert CSV data to network data"


complete -c xan -n '__fish_seen_subcommand_from help' -s O -l open -d 'Open the desired docs in a web browser.'
complete -c xan -n '__fish_seen_subcommand_from help' -s p -l pager -d 'Pipe the help into a pager (Same as piping'
complete -c xan -n '__fish_seen_subcommand_from help' -s S -l section -d '<query> Filter the `functions` doc to only include'
complete -c xan -n '__fish_seen_subcommand_from help' -l json -d 'Dump the help as JSON data.'
complete -c xan -n '__fish_seen_subcommand_from help' -l md -d 'Dump the help as Markdown.'
complete -c xan -n '__fish_seen_subcommand_from help' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from headers' -s j -l just-names -d 'Only show the header names (hide column index).'
complete -c xan -n '__fish_seen_subcommand_from headers' -l csv -d 'Return headers as a CSV file, with file path as'
complete -c xan -n '__fish_seen_subcommand_from headers' -s s -l start -d '<n> Column indices will start from given number.'
complete -c xan -n '__fish_seen_subcommand_from headers' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from headers' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from headers' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from view' -s s -l select -d "<arg> Select the columns to visualize. See 'xan select -h'"
complete -c xan -n '__fish_seen_subcommand_from view' -s t -l theme -d '<name> Theme for the table display, one of: "table", "borderless",'
complete -c xan -n '__fish_seen_subcommand_from view' -s p -l pager -d 'Automatically use the "less" command to page the results.'
complete -c xan -n '__fish_seen_subcommand_from view' -s A -l all -d 'Remove the row limit and display everything.'
complete -c xan -n '__fish_seen_subcommand_from view' -s l -l limit -d '<number> Maximum of rows to read into memory. Use -A, --all or'
complete -c xan -n '__fish_seen_subcommand_from view' -s R -l rainbow -d 'Alternating colors for columns, rather than color by value type.'
complete -c xan -n '__fish_seen_subcommand_from view' -l cols -d '<num> Width of the graph in terminal columns, i.e. characters.'
complete -c xan -n '__fish_seen_subcommand_from view' -s C -l force-colors -d 'Force colors even if output is not supposed to be able to'
complete -c xan -n '__fish_seen_subcommand_from view' -s e -l expand -d 'Expand the table so that in can be easily piped to'
complete -c xan -n '__fish_seen_subcommand_from view' -s E -l sanitize-emojis -d 'Replace emojis by their shortcode to avoid formatting issues.'
complete -c xan -n '__fish_seen_subcommand_from view' -s S -l significance -d '<n> Maximum floating point significance used to format numbers.'
complete -c xan -n '__fish_seen_subcommand_from view' -s I -l hide-index -d 'Hide the row index on the left.'
complete -c xan -n '__fish_seen_subcommand_from view' -s H -l hide-headers -d 'Hide the headers. Implied when -n, --no-headers is given.'
complete -c xan -n '__fish_seen_subcommand_from view' -s M -l hide-info -d 'Hide information about number of displayed columns, rows etc.'
complete -c xan -n '__fish_seen_subcommand_from view' -s g -l groupby -d '<cols> Isolate and emphasize groups of rows, represented by consecutive'
complete -c xan -n '__fish_seen_subcommand_from view' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from view' -s n -l no-headers -d 'When set, the first row will not considered as being'
complete -c xan -n '__fish_seen_subcommand_from view' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from flatten' -s s -l select -d "<arg> Select the columns to visualize. See 'xan select -h'"
complete -c xan -n '__fish_seen_subcommand_from flatten' -s l -l limit -d '<n> Maximum number of rows to read. Defaults to read the whole'
complete -c xan -n '__fish_seen_subcommand_from flatten' -s c -l condense -d "Don't wrap cell values on new lines but truncate them"
complete -c xan -n '__fish_seen_subcommand_from flatten' -s w -l wrap -d "Wrap cell values all while minding the header's indent."
complete -c xan -n '__fish_seen_subcommand_from flatten' -l cols -d '<num> Width of the graph in terminal columns, i.e. characters.'
complete -c xan -n '__fish_seen_subcommand_from flatten' -s R -l rainbow -d 'Alternating colors for cells, rather than color by value type.'
complete -c xan -n '__fish_seen_subcommand_from flatten' -s C -l force-colors -d 'Force colors even if output is not supposed to be able to'
complete -c xan -n '__fish_seen_subcommand_from flatten' -s S -l split -d '<cols> Split columns containing multiple values separated by --sep'
complete -c xan -n '__fish_seen_subcommand_from flatten' -l sep -d '<sep> Delimiter separating multiple values in cells splitted'
complete -c xan -n '__fish_seen_subcommand_from flatten' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from flatten' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from flatten' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from hist' -l name -d '<name> Name of the represented field when no field column is'
complete -c xan -n '__fish_seen_subcommand_from hist' -s f -l field -d '<name> Name of the field column. I.e. the one containing'
complete -c xan -n '__fish_seen_subcommand_from hist' -s l -l label -d '<name> Name of the label column. I.e. the one containing the'
complete -c xan -n '__fish_seen_subcommand_from hist' -s v -l value -d '<name> Name of the count column. I.e. the one containing the value'
complete -c xan -n '__fish_seen_subcommand_from hist' -s B -l bar-size -d '<size> Size of the bar characters between "small", "medium"'
complete -c xan -n '__fish_seen_subcommand_from hist' -l cols -d '<num> Width of the graph in terminal columns, i.e. characters.'
complete -c xan -n '__fish_seen_subcommand_from hist' -s R -l rainbow -d 'Alternating colors for the bars.'
complete -c xan -n '__fish_seen_subcommand_from hist' -s m -l domain-max -d '<type> If "max" max bar length will be scaled to the'
complete -c xan -n '__fish_seen_subcommand_from hist' -s c -l category -d '<col> Name of the categorical column that will be used to'
complete -c xan -n '__fish_seen_subcommand_from hist' -s C -l force-colors -d 'Force colors even if output is not supposed to be able to'
complete -c xan -n '__fish_seen_subcommand_from hist' -s P -l hide-percent -d "Don't show percentages."
complete -c xan -n '__fish_seen_subcommand_from hist' -s u -l unit -d '<unit> Value unit.'
complete -c xan -n '__fish_seen_subcommand_from hist' -s D -l dates -d 'Set to indicate your values are dates (supporting year, year-month or'
complete -c xan -n '__fish_seen_subcommand_from hist' -s G -l compress-gaps -d '<n> If given, will compress gaps of minimum <n> consecutive'
complete -c xan -n '__fish_seen_subcommand_from hist' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from hist' -s n -l no-headers -d 'When set, the file will be considered as having no'
complete -c xan -n '__fish_seen_subcommand_from hist' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from plot' -s L -l line -d 'Whether to draw a line plot instead of the default scatter plot.'
complete -c xan -n '__fish_seen_subcommand_from plot' -s B -l bars -d 'Whether to draw bars instead of the default scatter plot.'
complete -c xan -n '__fish_seen_subcommand_from plot' -s T -l time -d 'Use to indicate that the x axis is temporal. The axis will be'
complete -c xan -n '__fish_seen_subcommand_from plot' -l count -d 'Omit the y column and count rows instead. Only relevant when'
complete -c xan -n '__fish_seen_subcommand_from plot' -s c -l category -d '<col> Name of the categorical column that will be used to'
complete -c xan -n '__fish_seen_subcommand_from plot' -s Y -l add-series -d '<col> Name of another column of y values to add as a new series.'
complete -c xan -n '__fish_seen_subcommand_from plot' -s R -l regression-line -d 'Draw a regression line. Only works when drawing a scatter plot with'
complete -c xan -n '__fish_seen_subcommand_from plot' -s g -l granularity -d '<g> Force temporal granularity for x axis discretization when'
complete -c xan -n '__fish_seen_subcommand_from plot' -l cols -d '<num> Width of the graph in terminal columns, i.e. characters.'
complete -c xan -n '__fish_seen_subcommand_from plot' -l rows -d '<num> Height of the graph in terminal rows, i.e. characters.'
complete -c xan -n '__fish_seen_subcommand_from plot' -s S -l small-multiples -d '<n> Display small multiples (also called facet grids) of datasets'
complete -c xan -n '__fish_seen_subcommand_from plot' -l share-x-scale -d '<yes|no> Give "yes" to share x scale for all plot when drawing small multiples with -S,'
complete -c xan -n '__fish_seen_subcommand_from plot' -l share-y-scale -d '<yes|no> Give "yes" to share y scale for all plot when drawing small multiples with -S,'
complete -c xan -n '__fish_seen_subcommand_from plot' -s M -l marker -d "<name> Marker to use. Can be one of (by order of size): 'braille', 'dot',"
complete -c xan -n '__fish_seen_subcommand_from plot' -s G -l grid -d 'Draw a background grid.'
complete -c xan -n '__fish_seen_subcommand_from plot' -l x-ticks -d '<n> Approx. number of x-axis graduation steps. Will default to some'
complete -c xan -n '__fish_seen_subcommand_from plot' -l y-ticks -d '<n> Approx. number of y-axis graduation steps. Will default to some'
complete -c xan -n '__fish_seen_subcommand_from plot' -l x-min -d '<n> Force a minimum value for the x axis.'
complete -c xan -n '__fish_seen_subcommand_from plot' -l x-max -d '<n> Force a maximum value for the x axis.'
complete -c xan -n '__fish_seen_subcommand_from plot' -l y-min -d '<n> Force a minimum value for the y axis.'
complete -c xan -n '__fish_seen_subcommand_from plot' -l y-max -d '<n> Force a maximum value for the y axis.'
complete -c xan -n '__fish_seen_subcommand_from plot' -l x-scale -d '<scale> Apply a scale to the x axis. Can be one of "lin" or "log".'
complete -c xan -n '__fish_seen_subcommand_from plot' -l y-scale -d '<scale> Apply a scale to the y axis. Can be one of "lin" or "log".'
complete -c xan -n '__fish_seen_subcommand_from plot' -s C -l force-colors -d 'Force colors even if output is not supposed to be able to'
complete -c xan -n '__fish_seen_subcommand_from plot' -s i -l ignore -d 'Ignore values that cannot be correctly parsed.'
complete -c xan -n '__fish_seen_subcommand_from plot' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from plot' -s n -l no-headers -d 'When set, the file will be considered as having no'
complete -c xan -n '__fish_seen_subcommand_from plot' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s G -l gradient -d '<name> Gradient to use. Use --show-gradients to see what is'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s m -l min -d '<n> Minimum value for a cell in the heatmap. Will clamp'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s M -l max -d '<n> Maximum value for a cell in the heatmap. Will clamp'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -l normalize -d "<mode> How to normalize the heatmap's values. Can be one of"
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s S -l size -d '<n> Size of the heatmap square in terminal rows.'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s D -l diverging -d 'Use a diverging color gradient. Currently only shorthand'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -l cram -d 'Attempt to cram column labels over the columns.'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s N -l show-numbers -d 'Whether to attempt to show numbers in the cells.'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s C -l force-colors -d 'Force colors even if output is not supposed to be able to'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -l show-gradients -d 'Display a showcase of available gradients.'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s n -l no-headers -d 'When set, the file will be considered as having no'
complete -c xan -n '__fish_seen_subcommand_from heatmap' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from progress' -s S -l smooth -d 'Flush output buffer each time one row is written.'
complete -c xan -n '__fish_seen_subcommand_from progress' -s B -l bytes -d 'Display progress on file bytes, rather than parsing CSV lines.'
complete -c xan -n '__fish_seen_subcommand_from progress' -l prebuffer -d '<n> Number of megabytes of the file to prebuffer to attempt'
complete -c xan -n '__fish_seen_subcommand_from progress' -l title -d '<string> Title of the loading bar.'
complete -c xan -n '__fish_seen_subcommand_from progress' -l total -d '<n> Total number of rows of given CSV file.'
complete -c xan -n '__fish_seen_subcommand_from progress' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from progress' -s n -l no-headers -d 'When set, the first row will be included in'
complete -c xan -n '__fish_seen_subcommand_from progress' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from progress' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from search' -s e -l exact -d 'Perform an exact match.'
complete -c xan -n '__fish_seen_subcommand_from search' -s r -l regex -d 'Use a regex to perform the match.'
complete -c xan -n '__fish_seen_subcommand_from search' -s E -l empty -d 'Search for empty cells, i.e. filter out'
complete -c xan -n '__fish_seen_subcommand_from search' -s N -l non-empty -d 'Search for non-empty cells, i.e. filter out'
complete -c xan -n '__fish_seen_subcommand_from search' -s u -l url-prefix -d 'Match by url prefix, i.e. cells must contain urls'
complete -c xan -n '__fish_seen_subcommand_from search' -l patterns -d '<path> Path to a text file (use "-" for stdin), containing multiple'
complete -c xan -n '__fish_seen_subcommand_from search' -l pattern-column -d '<name> When given a column name, --patterns file will be considered a CSV'
complete -c xan -n '__fish_seen_subcommand_from search' -l replacement-column -d '<name> When given with both --patterns & --pattern-column, indicates the'
complete -c xan -n '__fish_seen_subcommand_from search' -s i -l ignore-case -d 'Case insensitive search.'
complete -c xan -n '__fish_seen_subcommand_from search' -s s -l select -d "<arg> Select the columns to search. See 'xan select -h'"
complete -c xan -n '__fish_seen_subcommand_from search' -s v -l invert-match -d 'Select only rows that did not match'
complete -c xan -n '__fish_seen_subcommand_from search' -s A -l all -d 'Only return a row when ALL columns from the given selection'
complete -c xan -n '__fish_seen_subcommand_from search' -s c -l count -d '<column> If given, the command will not filter rows but will instead'
complete -c xan -n '__fish_seen_subcommand_from search' -s R -l replace -d '<with> If given, the command will not filter rows but will instead'
complete -c xan -n '__fish_seen_subcommand_from search' -l overlapping -d 'When used with -c/--count, return the count of overlapping'
complete -c xan -n '__fish_seen_subcommand_from search' -s l -l limit -d '<n> Maximum of number rows to return. Useful to avoid downstream'
complete -c xan -n '__fish_seen_subcommand_from search' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from search' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from search' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from search' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from filter' -s p -l parallel -d 'Whether to use parallelization to speed up computations.'
complete -c xan -n '__fish_seen_subcommand_from filter' -s t -l threads -d '<threads> Parellize computations using this many threads. Use -p, --parallel'
complete -c xan -n '__fish_seen_subcommand_from filter' -s v -l invert-match -d 'If set, will invert the evaluated value.'
complete -c xan -n '__fish_seen_subcommand_from filter' -s l -l limit -d '<n> Maximum number of rows to return. Useful to avoid downstream'
complete -c xan -n '__fish_seen_subcommand_from filter' -s E -l errors -d '<policy> What to do with evaluation errors. One of:'
complete -c xan -n '__fish_seen_subcommand_from filter' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from filter' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from filter' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from filter' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from slice' -s s -l start -d '<n> The index of the record to slice from.'
complete -c xan -n '__fish_seen_subcommand_from slice' -l skip -d '<n> Same as -s, --start.'
complete -c xan -n '__fish_seen_subcommand_from slice' -s e -l end -d '<n> The index of the record to slice to.'
complete -c xan -n '__fish_seen_subcommand_from slice' -s l -l len -d '<n> The length of the slice (can be used instead'
complete -c xan -n '__fish_seen_subcommand_from slice' -s i -l index -d '<i> Slice a single record (shortcut for -s N -l 1).'
complete -c xan -n '__fish_seen_subcommand_from slice' -s B -l byte-offset -d '<b> Byte offset to seek to in the sliced file. This can'
complete -c xan -n '__fish_seen_subcommand_from slice' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from slice' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from slice' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from slice' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from top' -s l -l limit -d '<n> Number of top items to return. Cannot be < 1.'
complete -c xan -n '__fish_seen_subcommand_from top' -s R -l reverse -d 'Reverse order.'
complete -c xan -n '__fish_seen_subcommand_from top' -s g -l groupby -d '<cols> Return top n values per group, represented'
complete -c xan -n '__fish_seen_subcommand_from top' -s r -l rank -d '<col> Name of a rank column to prepend.'
complete -c xan -n '__fish_seen_subcommand_from top' -s T -l ties -d 'Keep all rows tied for last. Will therefore'
complete -c xan -n '__fish_seen_subcommand_from top' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from top' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from top' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from top' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from sample' -l seed -d '<number> RNG seed.'
complete -c xan -n '__fish_seen_subcommand_from sample' -s w -l weight -d '<column> Column containing weights to bias the sample.'
complete -c xan -n '__fish_seen_subcommand_from sample' -s g -l groupby -d '<cols> Return a sample per group.'
complete -c xan -n '__fish_seen_subcommand_from sample' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from sample' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from sample' -s n -l no-headers -d 'When set, the first row will be consider as part of'
complete -c xan -n '__fish_seen_subcommand_from sample' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from sort' -l check -d 'Verify whether the file is already sorted.'
complete -c xan -n '__fish_seen_subcommand_from sort' -s s -l select -d '<arg> Select a subset of columns to sort.'
complete -c xan -n '__fish_seen_subcommand_from sort' -s N -l numeric -d 'Compare according to string numerical value'
complete -c xan -n '__fish_seen_subcommand_from sort' -s R -l reverse -d 'Reverse order'
complete -c xan -n '__fish_seen_subcommand_from sort' -s c -l count -d '<name> Number of times the line was consecutively duplicated.'
complete -c xan -n '__fish_seen_subcommand_from sort' -s u -l uniq -d 'When set, identical consecutive lines will be dropped'
complete -c xan -n '__fish_seen_subcommand_from sort' -s U -l unstable -d 'Unstable sort. Can improve performance.'
complete -c xan -n '__fish_seen_subcommand_from sort' -s p -l parallel -d 'Whether to use parallelism to improve performance.'
complete -c xan -n '__fish_seen_subcommand_from sort' -s e -l external -d 'Whether to use external sorting if you cannot fit the'
complete -c xan -n '__fish_seen_subcommand_from sort' -l tmp-dir -d '<arg> Directory where external sorting chunks will be written.'
complete -c xan -n '__fish_seen_subcommand_from sort' -s m -l memory-limit -d '<arg> Maximum allowed memory when using external sorting, in'
complete -c xan -n '__fish_seen_subcommand_from sort' -s C -l cells -d 'Sort the selected cell values instead of the file itself,'
complete -c xan -n '__fish_seen_subcommand_from sort' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from sort' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from sort' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from sort' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from dedup' -l check -d 'Verify whether the selection has any duplicates, i.e. whether'
complete -c xan -n '__fish_seen_subcommand_from dedup' -s s -l select -d '<arg> Select a subset of columns to on which to deduplicate.'
complete -c xan -n '__fish_seen_subcommand_from dedup' -s S -l sorted -d 'Use if you know your file is already sorted on the deduplication'
complete -c xan -n '__fish_seen_subcommand_from dedup' -s l -l keep-last -d 'Keep the last row having a specific identity, rather than'
complete -c xan -n '__fish_seen_subcommand_from dedup' -s e -l external -d 'Use an external btree index to keep the index on disk and avoid'
complete -c xan -n '__fish_seen_subcommand_from dedup' -l keep-duplicates -d 'Emit only the duplicated rows.'
complete -c xan -n '__fish_seen_subcommand_from dedup' -l choose -d '<expr> Evaluate an expression that must return whether to'
complete -c xan -n '__fish_seen_subcommand_from dedup' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from dedup' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from dedup' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from dedup' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from shuffle' -l seed -d '<number> RNG seed.'
complete -c xan -n '__fish_seen_subcommand_from shuffle' -s m -l in-memory -d 'Load all CSV data in memory before shuffling it. Can'
complete -c xan -n '__fish_seen_subcommand_from shuffle' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from shuffle' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from shuffle' -s n -l no-headers -d 'When set, the first row will not be included in'
complete -c xan -n '__fish_seen_subcommand_from shuffle' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s s -l select -d '<arg> Select a subset of columns to compute frequencies'
complete -c xan -n '__fish_seen_subcommand_from frequency' -l sep -d '<char> Split the cell into multiple values to count using the'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s g -l groupby -d '<cols> If given, will compute frequency tables per group'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s A -l all -d 'Remove the limit.'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s l -l limit -d '<arg> Limit the frequency table to the N most common'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s a -l approx -d 'If set, return the items most likely having the top counts,'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s t -l threshold -d "<arg> If set, won't return items having a count less than"
complete -c xan -n '__fish_seen_subcommand_from frequency' -s N -l no-extra -d "Don't include empty cells & remaining counts."
complete -c xan -n '__fish_seen_subcommand_from frequency' -s p -l parallel -d 'Allow sorting to be done in parallel. This is only'
complete -c xan -n '__fish_seen_subcommand_from frequency' -l no-limit-we-reach-for-the-sky -d 'Nothing to see here...'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s n -l no-headers -d 'When set, the first row will NOT be included'
complete -c xan -n '__fish_seen_subcommand_from frequency' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from groupby' -l keep -d '<cols> Keep this selection of columns, in addition to'
complete -c xan -n '__fish_seen_subcommand_from groupby' -s S -l sorted -d 'Use this flag to indicate that the file is already sorted on the'
complete -c xan -n '__fish_seen_subcommand_from groupby' -s e -l errors -d '<policy> What to do with evaluation errors. One of:'
complete -c xan -n '__fish_seen_subcommand_from groupby' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from groupby' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from groupby' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from groupby' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from stats' -s s -l select -d '<arg> Select a subset of columns to compute stats for.'
complete -c xan -n '__fish_seen_subcommand_from stats' -s g -l groupby -d '<cols> If given, will compute stats per group as defined by'
complete -c xan -n '__fish_seen_subcommand_from stats' -s A -l all -d 'Shorthand for -cq.'
complete -c xan -n '__fish_seen_subcommand_from stats' -s c -l cardinality -d 'Show cardinality and modes.'
complete -c xan -n '__fish_seen_subcommand_from stats' -s q -l quartiles -d 'Show quartiles.'
complete -c xan -n '__fish_seen_subcommand_from stats' -s a -l approx -d 'Compute approximated statistics.'
complete -c xan -n '__fish_seen_subcommand_from stats' -l nulls -d 'Include empty values in the population size for computing'
complete -c xan -n '__fish_seen_subcommand_from stats' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from stats' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from stats' -s n -l no-headers -d 'When set, the first row will NOT be interpreted'
complete -c xan -n '__fish_seen_subcommand_from stats' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from agg' -s E -l errors -d '<policy> What to do with evaluation errors. One of:'
complete -c xan -n '__fish_seen_subcommand_from agg' -l cols -d '<columns> Aggregate a selection of columns per row'
complete -c xan -n '__fish_seen_subcommand_from agg' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from agg' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from agg' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from agg' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from bins' -s s -l select -d '<arg> Select a subset of columns to compute bins'
complete -c xan -n '__fish_seen_subcommand_from bins' -s b -l bins -d '<number> Number of bins. Will default to using various heuristics'
complete -c xan -n '__fish_seen_subcommand_from bins' -s E -l nice -d 'Whether to choose nice boundaries for the bins.'
complete -c xan -n '__fish_seen_subcommand_from bins' -s l -l label -d '<mode> Label to choose for the bins (that will be placed in the'
complete -c xan -n '__fish_seen_subcommand_from bins' -s m -l min -d '<min> Override min value.'
complete -c xan -n '__fish_seen_subcommand_from bins' -s M -l max -d '<max> Override max value.'
complete -c xan -n '__fish_seen_subcommand_from bins' -s N -l no-extra -d "Don't include, nulls, nans and out-of-bounds counts."
complete -c xan -n '__fish_seen_subcommand_from bins' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from bins' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from bins' -s n -l no-headers -d 'When set, the file will be considered as having no'
complete -c xan -n '__fish_seen_subcommand_from bins' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from cat' -s p -l pad -d 'When concatenating columns, this flag will cause'
complete -c xan -n '__fish_seen_subcommand_from cat' -l paths -d '<input> When concatenating rows, give a text file (use "-" for stdin)'
complete -c xan -n '__fish_seen_subcommand_from cat' -l path-column -d '<name> When given a column name, --paths will be considered as CSV, and paths'
complete -c xan -n '__fish_seen_subcommand_from cat' -s S -l source-column -d '<name> Name of a column to prepend in the output of "cat rows"'
complete -c xan -n '__fish_seen_subcommand_from cat' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from cat' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from cat' -s n -l no-headers -d 'When set, the first row will NOT be interpreted'
complete -c xan -n '__fish_seen_subcommand_from cat' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from join' -l left -d 'Do an "outer left" join. This returns all rows in'
complete -c xan -n '__fish_seen_subcommand_from join' -l right -d 'Do an "outer right" join. This returns all rows in'
complete -c xan -n '__fish_seen_subcommand_from join' -l full -d 'Do a "full outer" join. This returns all rows in'
complete -c xan -n '__fish_seen_subcommand_from join' -l cross -d 'This returns the cartesian product of the given CSV'
complete -c xan -n '__fish_seen_subcommand_from join' -s i -l ignore-case -d 'When set, joins are done case insensitively.'
complete -c xan -n '__fish_seen_subcommand_from join' -l nulls -d 'When set, joins will work on empty fields.'
complete -c xan -n '__fish_seen_subcommand_from join' -s L -l prefix-left -d '<prefix> Add a prefix to the names of the columns in the'
complete -c xan -n '__fish_seen_subcommand_from join' -s R -l prefix-right -d '<prefix> Add a prefix to the names of the columns in the'
complete -c xan -n '__fish_seen_subcommand_from join' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from join' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from join' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from join' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n __fish_no_arguments -l version -d "Print the tool's version"
complete -c xan -n __fish_no_arguments -l version -d "Print the tool's version"
complete -c xan -n '__fish_seen_subcommand_from merge' -s s -l select -d '<arg> Select a subset of columns to sort.'
complete -c xan -n '__fish_seen_subcommand_from merge' -s N -l numeric -d 'Compare according to string numerical value'
complete -c xan -n '__fish_seen_subcommand_from merge' -s R -l reverse -d 'Reverse order'
complete -c xan -n '__fish_seen_subcommand_from merge' -s u -l uniq -d 'When set, identical consecutive lines will be dropped'
complete -c xan -n '__fish_seen_subcommand_from merge' -s S -l source-column -d '<name> Name of a column to prepend in the output of the command'
complete -c xan -n '__fish_seen_subcommand_from merge' -l paths -d '<input> Give a text file (use "-" for stdin) containing one path of'
complete -c xan -n '__fish_seen_subcommand_from merge' -l path-column -d '<name> When given a column name, --paths will be considered as CSV, and paths'
complete -c xan -n '__fish_seen_subcommand_from merge' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from merge' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from merge' -s n -l no-headers -d 'When set, the first row will NOT be interpreted'
complete -c xan -n '__fish_seen_subcommand_from merge' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from select' -s A -l append -d 'Append the selection to the rows instead of'
complete -c xan -n '__fish_seen_subcommand_from select' -s e -l evaluate -d 'Toggle expression evaluation rather than using the'
complete -c xan -n '__fish_seen_subcommand_from select' -s E -l errors -d '<policy> What to do with evaluation errors. One of:'
complete -c xan -n '__fish_seen_subcommand_from select' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from select' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from select' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from select' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from drop' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from drop' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from drop' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from drop' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from map' -s p -l parallel -d 'Whether to use parallelization to speed up computations.'
complete -c xan -n '__fish_seen_subcommand_from map' -s t -l threads -d '<threads> Parellize computations using this many threads. Use -p, --parallel'
complete -c xan -n '__fish_seen_subcommand_from map' -s E -l errors -d '<policy> What to do with evaluation errors. One of:'
complete -c xan -n '__fish_seen_subcommand_from map' -l error-column -d '<name> Name of the column containing errors if -E/--errors'
complete -c xan -n '__fish_seen_subcommand_from map' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from map' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from map' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from map' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from transform' -s r -l rename -d '<name> New name for the transformed column.'
complete -c xan -n '__fish_seen_subcommand_from transform' -s p -l parallel -d 'Whether to use parallelization to speed up computations.'
complete -c xan -n '__fish_seen_subcommand_from transform' -s t -l threads -d '<threads> Parellize computations using this many threads. Use -p, --parallel'
complete -c xan -n '__fish_seen_subcommand_from transform' -s E -l errors -d '<policy> What to do with evaluation errors. One of:'
complete -c xan -n '__fish_seen_subcommand_from transform' -l error-column -d '<name> Name of the column containing errors if'
complete -c xan -n '__fish_seen_subcommand_from transform' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from transform' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from transform' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from transform' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from enum' -s c -l column-name -d '<arg> Name of the column to prepend. Will default to "index",'
complete -c xan -n '__fish_seen_subcommand_from enum' -s S -l start -d '<arg> Number to count from. [default: 0].'
complete -c xan -n '__fish_seen_subcommand_from enum' -s B -l byte-offset -d 'Whether to indicate the byte offset of the row'
complete -c xan -n '__fish_seen_subcommand_from enum' -s A -l accumulate -d 'When use with -B, --byte-offset, will accumulate the'
complete -c xan -n '__fish_seen_subcommand_from enum' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from enum' -s n -l no-headers -d 'When set, the first row will not considered as being'
complete -c xan -n '__fish_seen_subcommand_from enum' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from enum' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from flatmap' -s r -l replace -d '<column> Name of the column that will be replaced by the mapped values.'
complete -c xan -n '__fish_seen_subcommand_from flatmap' -s p -l parallel -d 'Whether to use parallelization to speed up computations.'
complete -c xan -n '__fish_seen_subcommand_from flatmap' -s t -l threads -d '<threads> Parellize computations using this many threads. Use -p, --parallel'
complete -c xan -n '__fish_seen_subcommand_from flatmap' -s E -l errors -d '<policy> What to do with evaluation errors. One of:'
complete -c xan -n '__fish_seen_subcommand_from flatmap' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from flatmap' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from flatmap' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from flatmap' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from fill' -s s -l select -d '<cols> Selection of columns to fill.'
complete -c xan -n '__fish_seen_subcommand_from fill' -s v -l value -d '<value> Fill empty cells using provided value instead of using'
complete -c xan -n '__fish_seen_subcommand_from fill' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from fill' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from fill' -s n -l no-headers -d 'When set, the file will be considered as having no'
complete -c xan -n '__fish_seen_subcommand_from fill' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from blank' -s s -l select -d '<cols> Selection of columns to blank down.'
complete -c xan -n '__fish_seen_subcommand_from blank' -s r -l redact -d '<value> Redact the blanked down values using the provided'
complete -c xan -n '__fish_seen_subcommand_from blank' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from blank' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from blank' -s n -l no-headers -d 'When set, the file will be considered as having no'
complete -c xan -n '__fish_seen_subcommand_from blank' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from behead' -s A -l append -d 'Only drop headers if output already exists and'
complete -c xan -n '__fish_seen_subcommand_from behead' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from behead' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from behead' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from rename' -s s -l select -d "<arg> Select the columns to rename. See 'xan select -h'"
complete -c xan -n '__fish_seen_subcommand_from rename' -s p -l prefix -d '<prefix> Prefix to add to all the column names.'
complete -c xan -n '__fish_seen_subcommand_from rename' -s S -l slugify -d 'Transform the column name so that they are safe to'
complete -c xan -n '__fish_seen_subcommand_from rename' -s f -l force -d 'Ignore unknown columns to be renamed.'
complete -c xan -n '__fish_seen_subcommand_from rename' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from rename' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from rename' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from rename' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from input' -l tabs -d "Same as -d '\\t', i.e. use tabulations as delimiter."
complete -c xan -n '__fish_seen_subcommand_from input' -l quote -d '<char> The quote character to use. [default: "]'
complete -c xan -n '__fish_seen_subcommand_from input' -l escape -d '<char> The escape character to use. When not specified,'
complete -c xan -n '__fish_seen_subcommand_from input' -l no-quoting -d 'Disable quoting completely.'
complete -c xan -n '__fish_seen_subcommand_from input' -s L -l skip-lines -d '<n> Skip the first <n> lines of the file.'
complete -c xan -n '__fish_seen_subcommand_from input' -s H -l skip-headers -d '<pattern> Skip header lines matching the given regex pattern.'
complete -c xan -n '__fish_seen_subcommand_from input' -s R -l skip-rows -d '<pattern> Skip rows matching the given regex pattern.'
complete -c xan -n '__fish_seen_subcommand_from input' -l vcf -d "Process a VCF file. Shorthand for --tabs -H '^##' and"
complete -c xan -n '__fish_seen_subcommand_from input' -l gtf -d "Process a GTF file. Shorthand for --tabs -H '^#!'."
complete -c xan -n '__fish_seen_subcommand_from input' -l gff -d "Process a GFF file. Shorthand for --tabs -H '^#[#!]'"
complete -c xan -n '__fish_seen_subcommand_from input' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from input' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from input' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from fixlengths' -s l -l length -d '<arg> Forcefully set the length of each record. If a'
complete -c xan -n '__fish_seen_subcommand_from fixlengths' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from fixlengths' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from fixlengths' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from fmt' -s i -l in-place -d 'Write the result in a temporary file and'
complete -c xan -n '__fish_seen_subcommand_from fmt' -s t -l out-delimiter -d '<arg> The field delimiter for writing CSV data.'
complete -c xan -n '__fish_seen_subcommand_from fmt' -l crlf -d "Use '\\r\\n' line endings in the output."
complete -c xan -n '__fish_seen_subcommand_from fmt' -l ascii -d 'Use ASCII field and record separators.'
complete -c xan -n '__fish_seen_subcommand_from fmt' -l tabs -d "Shorthand for -t '\\t'."
complete -c xan -n '__fish_seen_subcommand_from fmt' -l quote -d '<arg> The quote character to use. [default: "]'
complete -c xan -n '__fish_seen_subcommand_from fmt' -l quote-always -d 'Put quotes around every value.'
complete -c xan -n '__fish_seen_subcommand_from fmt' -l quote-never -d 'Never put quotes around values, even if this would'
complete -c xan -n '__fish_seen_subcommand_from fmt' -l escape -d '<arg> The escape character to use. When not specified,'
complete -c xan -n '__fish_seen_subcommand_from fmt' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from fmt' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from fmt' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from explode' -l sep -d '<sep> Separator to split the cells.'
complete -c xan -n '__fish_seen_subcommand_from explode' -s S -l singularize -d 'Singularize (supporting only very simple English-centric cases)'
complete -c xan -n '__fish_seen_subcommand_from explode' -s r -l rename -d '<name> New names for the exploded columns. Must be written'
complete -c xan -n '__fish_seen_subcommand_from explode' -s D -l drop-empty -d 'Drop rows when selected cells are empty.'
complete -c xan -n '__fish_seen_subcommand_from explode' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from explode' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from explode' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from explode' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from implode' -l sep -d '<sep> Separator that will be used to join the diverging cells.'
complete -c xan -n '__fish_seen_subcommand_from implode' -s P -l pluralize -d 'Pluralize (supporting only very simple English-centric cases)'
complete -c xan -n '__fish_seen_subcommand_from implode' -s r -l rename -d '<name> New name for the diverging column.'
complete -c xan -n '__fish_seen_subcommand_from implode' -l cmp -d '<column> Restrict the columns to compare to assert whether'
complete -c xan -n '__fish_seen_subcommand_from implode' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from implode' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from implode' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from implode' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from from' -s f -l format -d '<format> Format to convert from. Will be inferred from file'
complete -c xan -n '__fish_seen_subcommand_from from' -s s -l sheet -d '<name> Name of the sheet to convert. [default: Sheet1]'
complete -c xan -n '__fish_seen_subcommand_from from' -l sample-size -d '<n> Number of records to sample before emitting headers.'
complete -c xan -n '__fish_seen_subcommand_from from' -l key-column -d '<name> Name for the key column when parsing a JSON map.'
complete -c xan -n '__fish_seen_subcommand_from from' -l value-column -d '<name> Name for the value column when parsing a JSON map.'
complete -c xan -n '__fish_seen_subcommand_from from' -s c -l column -d '<name> Name of the column to create.'
complete -c xan -n '__fish_seen_subcommand_from from' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from from' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from to' -s B -l buffer-size -d '<size> Number of CSV rows to sample to infer column types.'
complete -c xan -n '__fish_seen_subcommand_from to' -l nulls -d 'Convert empty string to a null value.'
complete -c xan -n '__fish_seen_subcommand_from to' -l omit -d 'Ignore the empty values.'
complete -c xan -n '__fish_seen_subcommand_from to' -l dtype -d '<type> Number type to use for the npy conversion. Must be one of "f32"'
complete -c xan -n '__fish_seen_subcommand_from to' -s s -l select -d '<column> Column of file to emit as text. Will error if file'
complete -c xan -n '__fish_seen_subcommand_from to' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from to' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from to' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from to' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s e -l evaluate -d '<expr> If given, evaluate the given scraping expression.'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s f -l evaluate-file -d '<path> If given, evaluate the scraping expression found'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s I -l input-dir -d '<path> If given, target column will be understood'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s k -l keep -d '<column> Selection of columns from the input to keep in'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s p -l parallel -d 'Whether to use parallelization to speed up computations.'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s t -l threads -d '<threads> Parellize computations using this many threads. Use -p, --parallel'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s u -l url-column -d '<column> Column containing the base url for given HTML.'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s F -l foreach -d '<css> If given, will return one row per element matching'
complete -c xan -n '__fish_seen_subcommand_from scrape' -l sep -d '<char> Separator to use when serializing lists.'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from scrape' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from reverse' -s m -l in-memory -d 'Load all CSV data in memory before reversing it. Can'
complete -c xan -n '__fish_seen_subcommand_from reverse' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from reverse' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from reverse' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from reverse' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from transpose' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from transpose' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from transpose' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from split' -s s -l size -d '<arg> The number of records to write into each chunk.'
complete -c xan -n '__fish_seen_subcommand_from split' -s j -l jobs -d '<arg> The number of spliting jobs to run in parallel.'
complete -c xan -n '__fish_seen_subcommand_from split' -l filename -d '<filename> A filename template to use when constructing'
complete -c xan -n '__fish_seen_subcommand_from split' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from split' -s n -l no-headers -d 'When set, the first row will NOT be interpreted'
complete -c xan -n '__fish_seen_subcommand_from split' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from partition' -l filename -d '<filename> A filename template to use when constructing'
complete -c xan -n '__fish_seen_subcommand_from partition' -s p -l prefix-length -d '<n> Truncate the partition column after the'
complete -c xan -n '__fish_seen_subcommand_from partition' -s S -l sorted -d 'Use this flag if you know the file is sorted'
complete -c xan -n '__fish_seen_subcommand_from partition' -l drop -d 'Drop the partition column from results.'
complete -c xan -n '__fish_seen_subcommand_from partition' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from partition' -s n -l no-headers -d 'When set, the first row will NOT be interpreted'
complete -c xan -n '__fish_seen_subcommand_from partition' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s P -l preprocess -d '<op> Preprocessing, only able to use xan subcommands.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s S -l shell-preprocess -d '<op> Preprocessing commands that will run directly in your'
complete -c xan -n '__fish_seen_subcommand_from parallel' -l progress -d 'Display a progress bar for the parallel tasks.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s t -l threads -d '<n> Number of threads to use. Will default to a sensible'
complete -c xan -n '__fish_seen_subcommand_from parallel' -l path-column -d '<name> Name of the path column if stdin is given as a CSV file'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s S -l source-column -d '<name> If given, will return a CSV file containing a column with'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s B -l buffer-size -d '<n> Number of rows a thread is allowed to keep in memory'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s S -l source-column -d '<name> Name of a column to prepend in the output of indicating the'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s s -l select -d '<cols> Columns for which to build frequency tables.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -l sep -d '<char> Split the cell into multiple values to count using the'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s s -l select -d '<cols> Columns for which to build statistics.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s A -l all -d 'Shorthand for -cq.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s c -l cardinality -d 'Show cardinality and modes.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s q -l quartiles -d 'Show quartiles.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s a -l approx -d 'Show approximated statistics.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -l nulls -d 'Include empty values in the population size for computing'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s n -l no-headers -d 'When set, the first row will NOT be interpreted'
complete -c xan -n '__fish_seen_subcommand_from parallel' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from range' -s s -l start -d '<n> Start of the range. [default: 0]'
complete -c xan -n '__fish_seen_subcommand_from range' -l step -d '<n> Step of the range. [default: 1]'
complete -c xan -n '__fish_seen_subcommand_from range' -s c -l column-name -d '<name> Name of the column containing the range.'
complete -c xan -n '__fish_seen_subcommand_from range' -s i -l inclusive -d 'Include the end bound.'
complete -c xan -n '__fish_seen_subcommand_from range' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from range' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from eval' -s S -l serialize -d 'Serialize the value in CSV.'
complete -c xan -n '__fish_seen_subcommand_from eval' -s E -l explain -d 'Print concrete expression plan.'
complete -c xan -n '__fish_seen_subcommand_from eval' -s H -l headers -d '<names> Pretend headers, separated by commas, to consider.'
complete -c xan -n '__fish_seen_subcommand_from eval' -s R -l row -d '<values> Pretend row with comma-separated cells.'
complete -c xan -n '__fish_seen_subcommand_from eval' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from foreach' -s p -l parallel -d 'Whether to use parallelization to speed up computations.'
complete -c xan -n '__fish_seen_subcommand_from foreach' -s t -l threads -d '<threads> Parellize computations using this many threads. Use -p, --parallel'
complete -c xan -n '__fish_seen_subcommand_from foreach' -s E -l errors -d '<policy> What to do with evaluation errors. One of:'
complete -c xan -n '__fish_seen_subcommand_from foreach' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from foreach' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from foreach' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from foreach' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s c -l column -d '<name> Name for the token column. Will default to "tokens", "token"'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s p -l parallel -d 'Whether to use parallelization to speed up computations.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s t -l threads -d '<threads> Parellize computations using this many threads. Use -p, --parallel'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l keep-text -d 'Force keeping the text column in the output.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s S -l simple -d 'Use a simpler, more performant variant of the tokenizer but unable'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s N -l ngrams -d '<n> If given, will output token ngrams using the given n or the given'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s T -l token-type -d '<name> Name of a column to add containing the type of the tokens.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s D -l drop -d '<types> Types of tokens to drop from the results, separated by comma,'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s K -l keep -d '<types> Types of tokens to keep in the results, separated by comma,'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s m -l min-token -d '<n> Minimum characters count of a token to be included in the output.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s M -l max-token -d '<n> Maximum characters count of a token to be included in the output.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l stoplist -d '<path> Path to a .txt stoplist containing one word per line.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s J -l filter-junk -d 'Whether to apply some heuristics to filter out words that look like junk.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s L -l lower -d 'Whether to normalize token case using lower case.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s U -l unidecode -d 'Whether to normalize token text to ascii.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l split-hyphens -d 'Whether to split tokens by hyphens.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l stemmer -d '<name> Stemmer to normalize the tokens. Can be one of:'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s V -l vocab -d '<name> Path to a CSV file containing allowed vocabulary (or "-" for stdin).'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l vocab-token -d '<col> Column of vocabulary file containing allowed tokens.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l vocab-token-id -d '<col> Column of vocabulary file containing a token id to emit in place of the'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l sep -d '<delim> Character used to join tokens in the output cells. Will default'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l ngrams-sep -d '<delim> Separator to be use to join ngrams tokens.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s u -l uniq -d 'Sort and deduplicate the tokens.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s F -l flatmap -d '<expr> Evaluate an expression for each extracted token and return nothing,'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s A -l aerated -d 'Force paragraphs to be separated by a blank line, instead'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -l squeeze -d 'Collapse consecutive whitespace to produce a tidy output.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from tokenize' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from vocab' -s T -l token -d '<token-col> Name of column containing the tokens. Will default'
complete -c xan -n '__fish_seen_subcommand_from vocab' -s D -l doc -d "<doc-cols> Optional selection of columns representing a row's document."
complete -c xan -n '__fish_seen_subcommand_from vocab' -l sep -d "<delim> Delimiter used to separate tokens in one row's token cell."
complete -c xan -n '__fish_seen_subcommand_from vocab' -l implode -d 'If given, will implode the file over the token column so that'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l tf-weight -d '<weight> TF weighting scheme. One of "count", "binary", "ratio",'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l k1-value -d '<value> "k1" Factor for BM25 computation. [default: 1.2]'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l b-value -d '<value> "b" Factor for BM25 computation. [default: 0.75]'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l chi2-significance -d '<value> Filter doc,token pairs by only keeping significant ones wrt their'
complete -c xan -n '__fish_seen_subcommand_from vocab' -s w -l window -d '<n> Size of the co-occurrence window, in number of tokens around the currently'
complete -c xan -n '__fish_seen_subcommand_from vocab' -s F -l forward -d 'Whether to only consider a forward window when traversing token contexts.'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l distrib -d 'Compute directed distributional similarity metrics instead.'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l specificity -d 'Compute the lgl specificity score per token instead.'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l min-count -d '<n> Minimum number of co-occurrence count to be included in the result.'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l chi2-significance -d '<value> Filter doc,token pairs by only keeping significant ones wrt their'
complete -c xan -n '__fish_seen_subcommand_from vocab' -l G2-significance -d '<value> Filter doc,token pairs by only keeping significant ones wrt their'
complete -c xan -n '__fish_seen_subcommand_from vocab' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from vocab' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from vocab' -s n -l no-headers -d 'When set, the first row will not be interpreted'
complete -c xan -n '__fish_seen_subcommand_from vocab' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from cluster' -s k -l key -d '<expr> An expression to evaluate to generate a key'
complete -c xan -n '__fish_seen_subcommand_from cluster' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from cluster' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from cluster' -s n -l no-headers -d 'When set, the first row will not be evaled'
complete -c xan -n '__fish_seen_subcommand_from cluster' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from matrix' -s s -l select -d '<columns> Columns to consider for the correlation'
complete -c xan -n '__fish_seen_subcommand_from matrix' -s D -l fill-diagonal -d 'Whether to fill diagonal with ones.'
complete -c xan -n '__fish_seen_subcommand_from matrix' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from matrix' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from matrix' -s n -l no-headers -d 'When set, the file will be considered as having no'
complete -c xan -n '__fish_seen_subcommand_from matrix' -s d -l delimiter -d '<arg> The field delimiter foDirectedr reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from network' -s f -l format -d '<format> One of "json", "gexf" or "nodelist".'
complete -c xan -n '__fish_seen_subcommand_from network' -l gexf-version -d '<version> GEXF version to output. Can be one of "1.2"'
complete -c xan -n '__fish_seen_subcommand_from network' -s L -l largest-component -d 'Only keep the largest connected component'
complete -c xan -n '__fish_seen_subcommand_from network' -l stats -d 'Print useful statistics about the generated graph'
complete -c xan -n '__fish_seen_subcommand_from network' -s U -l undirected -d 'Whether the graph is undirected.'
complete -c xan -n '__fish_seen_subcommand_from network' -l nodes -d '<path> Path to a CSV file containing node metadata'
complete -c xan -n '__fish_seen_subcommand_from network' -l node-column -d '<name> Name of the column containing node keys.'
complete -c xan -n '__fish_seen_subcommand_from network' -s D -l disjoint-keys -d 'Pass this if you know both partitions of the graph'
complete -c xan -n '__fish_seen_subcommand_from network' -l degrees -d 'Whether to compute node degrees and add relevant columns to the'
complete -c xan -n '__fish_seen_subcommand_from network' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from network' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from network' -s n -l no-headers -d 'When set, the file will be considered as having no'
complete -c xan -n '__fish_seen_subcommand_from network' -s d -l delimiter -d '<arg> The field delimiter foDirectedr reading CSV data.'
complete -c xan -n '__fish_seen_subcommand_from count' -l csv -d 'Output the result as a single column, single row CSV file with'
complete -c xan -n '__fish_seen_subcommand_from count' -s h -l help -d 'Display this message'
complete -c xan -n '__fish_seen_subcommand_from count' -s o -l output -d '<file> Write output to <file> instead of stdout.'
complete -c xan -n '__fish_seen_subcommand_from count' -s n -l no-headers -d 'When set, the first row will not be included in'
complete -c xan -n '__fish_seen_subcommand_from count' -s d -l delimiter -d '<arg> The field delimiter for reading CSV data.'
